<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>RS Monitor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>

  <style>
    html, body { margin:0; padding:0; height:100%; }
    #map { width:100%; height:100dvh; }

    .info {
      position:absolute; top:15px; right:15px; z-index:10;
      padding:6px 8px; background:rgba(255,255,255,0.8);
      box-shadow:0 0 15px rgba(0,0,0,0.2);
      border-radius:5px; font-size:14px;
    }

    .epicenter-marker {
      position: relative;
      width: 20px;
      height: 20px;
    }
    .epicenter-marker::before,
    .epicenter-marker::after {
      content: '';
      position: absolute;
      top: 50%; left: 50%;
      width: 2px; height: 20px; background: red;
    }
    .epicenter-marker::before { transform:translate(-50%,-50%) rotate(45deg); }
    .epicenter-marker::after  { transform:translate(-50%,-50%) rotate(-45deg); }
  </style>
</head>
<body>

<div id="map"></div>
<div class="info"><b>観測点数:</b> 0</div>

<script>
  const map = new maplibregl.Map({
    container: 'map',
    style: {
      version: 8,
      sources: {
        google: {
          type: "raster",
          tiles: ["https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}"],
          tileSize: 256
        }
      },
      layers: [{ id:"google", type:"raster", source:"google" }]
    },
    center:[134.5,34.5], zoom:3, maxZoom:9, minZoom:3,
    attributionControl:false
  });

  const infoBox = document.querySelector(".info");
  const colorMap = {
    d:'#0000CD', e:'#0024E3', f:'#000ED6', g:'#0048FA',
    h:'#008CC2', i:'#00D08B', j:'#1FE460', k:'#7DFC21',
    l:'#BDFF0C', m:'#DEFF05', n:'#FFFF00', o:'#FFEE00',
    p:'#FFDD00', q:'#FFB600', r:'#FF9000', s:'#FF6A00',
    t:'#FF4400', u:'#FA2100', v:'#F50000', w:'#D00000',
    x:'#AA0000'
  };

  let geojson = { type:"FeatureCollection", features:[] };
  let siteCoords = [];
  let markersCount = 0;
  let lastGoodData = null;
  let epicenterMarker = null;

  map.on("load", () => {
    map.addSource("points", { type:"geojson", data:geojson });
    map.addLayer({
      id:"points-layer",
      type:"circle",
      source:"points",
      paint:{
        "circle-radius":2,
        "circle-color":["get","color"],
        "circle-stroke-color":"#ffffff",
        "circle-stroke-width":0.2,
        "circle-opacity":1
      }
    });

    map.addSource("pWaveSource",{ type:"geojson", data:{ type:"FeatureCollection", features:[] } });
    map.addSource("sWaveSource",{ type:"geojson", data:{ type:"FeatureCollection", features:[] } });
    map.addLayer({ id:"pWaveLayer", type:"line", source:"pWaveSource", paint:{ "line-color":"blue", "line-width":1 } });
    map.addLayer({ id:"sWaveLayer", type:"line", source:"sWaveSource", paint:{ "line-color":"red", "line-width":1 } });
  });

  fetch('https://weather-kyoshin.west.edge.storage-yahoo.jp/SiteList/sitelist.json')
    .then(r=>r.json())
    .then(async data=>{
      siteCoords = data.items;
      await forceInitialMarkers();
      updateMarkers();
    });

  function getRealTimeUrl(secondsAgo=5){
    let now=new Date();
    now.setSeconds(now.getSeconds()-secondsAgo);
    const YYYY=now.getFullYear();
    const MM=String(now.getMonth()+1).padStart(2,'0');
    const DD=String(now.getDate()).padStart(2,'0');
    const HH=String(now.getHours()).padStart(2,'0');
    const mm=String(now.getMinutes()).padStart(2,'0');
    const SS=String(now.getSeconds()).padStart(2,'0');
    return `https://weather-kyoshin.west.edge.storage-yahoo.jp/RealTimeData/${YYYY}${MM}${DD}/${YYYY}${MM}${DD}${HH}${mm}${SS}.json`;
  }

  async function forceInitialMarkers() {
    for (let t=5; t<=60; t+=5) {
      try {
        const r = await fetch(getRealTimeUrl(t));
        if (!r.ok) continue;
        const data = await r.json();
        applyData(data);
        lastGoodData = data;
        return;
      } catch(e){}
    }
    if (lastGoodData) applyData(lastGoodData);
  }

  function applyData(data){
    const intensities = data.realTimeData.intensity;
    const N = Math.min(intensities.length, siteCoords.length);

    geojson.features = [];
    markersCount = 0;

    for(let i=0; i<N; i++){
      let code = intensities.charAt(i);
      if(code === 'c') continue;

      markersCount++;
      geojson.features.push({
        type:"Feature",
        geometry:{ type:"Point", coordinates:[siteCoords[i][1], siteCoords[i][0]] },
        properties:{ color:colorMap[code]||"#AA0000" }
      });
    }

    map.getSource("points").setData(geojson);
    infoBox.innerHTML="<b>観測点数:</b> "+markersCount;
  }

  let loading=false;
  function updateMarkers(){
    if(loading || siteCoords.length===0) return;
    loading=true;

    fetch(getRealTimeUrl())
      .then(r=>{ if(!r.ok) throw new Error("no"); return r.json(); })
      .then(data=>{
        lastGoodData = data;
        applyData(data);
      })
      .catch(()=>{})
      .finally(()=>{ loading=false; });
  }

  setInterval(updateMarkers,100);

  function createCircleGeoJSON(center, radius, steps=32){
    const coords=[];
    const [lng,lat]=center;
    const latRad=lat*Math.PI/180;

    for(let i=0;i<=steps;i++){
      const angle=(i/steps)*2*Math.PI;
      const dx=(radius/111000)/Math.cos(latRad)*Math.cos(angle);
      const dy=(radius/111000)*Math.sin(angle);
      coords.push([lng+dx, lat+dy]);
    }
    return { type:"Feature", geometry:{ type:"Polygon", coordinates:[coords] } };
  }

  function updatePsWaveLayer(){
    fetch(getRealTimeUrl())
      .then(r=>r.json())
      .then(data=>{
        const w=data.psWave?.items;
        if(w && w.length>0){
          const lat=parseFloat(w[0].latitude.replace("N",""));
          const lng=parseFloat(w[0].longitude.replace("E",""));
          const center=[lng,lat];

          const distP = w[0].pRadius*1000;
          const distS = w[0].sRadius*1000;
          const timeP = w[0].pTime;
          const timeS = w[0].sTime;
          const originTime = w[0].originTime || (Date.now()/1000);

          const now = Date.now()/1000;
          const elapsed = Math.max(now-originTime, 0.001);

          const speedP = distP/Math.max(timeP,1);
          const speedS = distS/Math.max(timeS,1);

          const radiusP = speedP * elapsed;
          const radiusS = speedS * elapsed;

          map.getSource("pWaveSource").setData({ type:"FeatureCollection", features:[ createCircleGeoJSON(center,radiusP) ] });
          map.getSource("sWaveSource").setData({ type:"FeatureCollection", features:[ createCircleGeoJSON(center,radiusS) ] });

          if(!epicenterMarker){
            const el=document.createElement('div');
            el.className='epicenter-marker';
            epicenterMarker=new maplibregl.Marker({element:el}).setLngLat(center).addTo(map);
          } else {
            epicenterMarker.setLngLat(center);
          }
        } else {
          map.getSource("pWaveSource").setData({ type:"FeatureCollection", features:[] });
          map.getSource("sWaveSource").setData({ type:"FeatureCollection", features:[] });
          if(epicenterMarker){ epicenterMarker.remove(); epicenterMarker=null; }
        }
      })
      .catch(()=>{});
  }

  updatePsWaveLayer();
  setInterval(updatePsWaveLayer,10);
</script>

</body>
</html>
